# 双图层背景切换完整方案

## 问题描述

在poem和mountain页面中，背景图切换时出现白色闪屏问题。即使图片已经预加载到本地，切换时仍然会有卡顿，原因是：

1. **图片渲染需要时间**：即使预加载完成，小程序在显示图片时仍需要解析、解码、渲染
2. **切换时机不当**：在图片还没完全渲染时就开始透明度切换
3. **大图片渲染慢**：不同图片的渲染时间不同，导致切换体验不一致

## 完整解决方案

### 1. WXML结构修改

```xml
<!-- 双图层清晰背景 -->
<view class="background-wrapper">
  <image 
    wx:for="{{bgLayers}}" 
    wx:key="index" 
    class="bg-image {{item.visible ? 'visible' : ''}}" 
    src="{{item.url}}"
    mode="aspectFill"
    bindload="onBackgroundImageLoad"
    data-layer-index="{{index}}"
  ></image>
</view>
<!-- 双图层模糊背景 -->
<view class="blur-background-wrapper">
  <image 
    wx:for="{{bgLayers}}" 
    wx:key="index" 
    class="bg-image blur-image {{item.visible ? 'visible' : ''}}" 
    src="{{item.url}}"
    mode="aspectFill"
    bindload="onBackgroundImageLoad"
    data-layer-index="{{index}}"
  ></image>
</view>
```

### 2. JS核心逻辑

```javascript
// 双图层切换函数
switchBackgroundImage: function(newImageUrl) {
  if (!newImageUrl) return;

  // 优先使用预加载的本地路径
  const preloadedUrl = this.data.preloadedImages[newImageUrl];
  const finalImageUrl = preloadedUrl || newImageUrl;
  
  console.log('切换背景图:', {
    originalUrl: newImageUrl,
    preloadedUrl: preloadedUrl,
    finalUrl: finalImageUrl,
    hasPreloaded: !!preloadedUrl
  });

  const currentActiveIndex = this.data.activeLayerIndex;
  const nextActiveIndex = (currentActiveIndex + 1) % 2; // 0 -> 1, 1 -> 0

  // 设置待切换的图层索引，等待图片加载完成
  this.pendingLayerIndex = nextActiveIndex;
  this.pendingCurrentIndex = currentActiveIndex;

  // 先设置下一层的图片URL，但不显示
  this.setData({
    [`bgLayers[${nextActiveIndex}].url`]: finalImageUrl,
    [`bgLayers[${nextActiveIndex}].visible`]: false // 确保先隐藏
  });

  // 设置超时机制，避免图片加载失败时一直等待
  if (this.imageLoadTimeout) {
    clearTimeout(this.imageLoadTimeout);
  }
  
  this.imageLoadTimeout = setTimeout(() => {
    console.log('图片加载超时，强制切换');
    if (this.pendingLayerIndex === nextActiveIndex) {
      this.performLayerSwitch();
    }
  }, 300); // 300ms 超时
},

// 执行图层切换的具体逻辑
performLayerSwitch: function() {
  if (this.pendingLayerIndex === null || this.pendingCurrentIndex === null) {
    return;
  }

  console.log('执行图层切换');
  this.setData({
    [`bgLayers[${this.pendingCurrentIndex}].visible`]: false, // 当前层淡出
    [`bgLayers[${this.pendingLayerIndex}].visible`]: true,   // 下一层淡入
    activeLayerIndex: this.pendingLayerIndex
  });
  
  // 清除待切换状态
  this.pendingLayerIndex = null;
  this.pendingCurrentIndex = null;
  
  // 清除超时
  if (this.imageLoadTimeout) {
    clearTimeout(this.imageLoadTimeout);
    this.imageLoadTimeout = null;
  }
},

// 背景图片加载完成事件
onBackgroundImageLoad: function(e) {
  const layerIndex = e.currentTarget.dataset.layerIndex;
  console.log(`图层${layerIndex}图片加载完成`);
  
  // 检查是否是待切换的图层
  if (this.pendingLayerIndex === layerIndex) {
    console.log('待切换图层图片加载完成，开始切换透明度');
    this.performLayerSwitch();
  }
}
```

### 3. 方案特点

#### 优点
- **完美体验**：图片完全渲染后才切换，无白色闪屏
- **精确控制**：使用图片加载事件，时机最准确
- **容错机制**：300ms超时防止图片加载失败导致卡死
- **状态管理**：清晰的状态跟踪，避免重复切换

#### 缺点
- **性能开销**：每个图片都有事件监听器
- **复杂度高**：状态管理复杂，代码维护成本高
- **事件开销**：每次切换都会触发多个事件

### 4. 性能影响分析

#### 事件监听开销
- 双图层 × 2个容器 = 4个事件监听器
- 每次切换触发1-2个事件
- 事件处理函数执行开销

#### 状态管理开销
- `pendingLayerIndex` 和 `pendingCurrentIndex` 状态跟踪
- 超时定时器管理
- 状态清理逻辑

#### 内存开销
- 额外的状态变量
- 定时器引用
- 事件监听器引用

### 5. 适用场景

**推荐使用场景**：
- 对用户体验要求极高的应用
- 图片质量要求高，渲染时间差异大
- 用户对切换流畅度非常敏感

**不推荐使用场景**：
- 性能敏感的应用
- 图片较小，渲染时间短
- 对代码复杂度有严格限制

### 6. 替代方案

如果性能开销过大，可以考虑：

1. **轻量级延迟方案**：使用固定延迟时间
2. **图片尺寸优化**：减小图片尺寸，降低渲染时间
3. **预加载优化**：更激进的预加载策略
4. **渐进式加载**：先显示低质量图片，再替换高质量图片

## 总结

完整事件监听方案提供了最佳的切换体验，但代价是较高的性能开销和代码复杂度。在实际应用中，需要根据具体需求在性能和体验之间找到平衡点。
