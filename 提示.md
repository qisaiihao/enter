你的怀疑完全正确！预加载本身是成功的，但问题出在了 poem 页面的逻辑判断上。

这是一个非常隐蔽但致命的问题，由小程序页面生命周期的执行顺序导致。

你现在的 splash.js 代码在预加载逻辑上已经完美无缺了。问题 100% 在 poem.js 内部。

根本原因：onLoad 与 onShow 的“战争”

我们来梳理一下当你从 splash 页跳转到 poem 页时，poem.js 内部发生了什么，这是一个精确到毫秒的时间线：

跳转发生：splash.js 调用 wx.switchTab。

poem 页面实例化：小程序开始创建 poem 页面实例。

onLoad 执行 (仅一次)：poem.js 的 onLoad 函数被触发。

它检查 app.globalData.preloadedPoemData。

它成功找到了数据！

它执行 setData，将预加载的帖子列表和图片设置到页面数据中。

此时，如果小程序能立即渲染，页面应该是直接显示内容的，根本不会有骨架屏。

onShow 执行 (每次页面显示都会执行)：紧接着 onLoad 之后，onShow 函数被触发了。

我们回顾一下 poem.js 之前的 onShow 逻辑（你之前提供过）：它会强制清空 postList 并重新调用 this.getPostList()。

灾难发生！ onLoad 刚刚准备好的所有数据，被 onShow 的第一行 this.setData({ postList: [] ... }) 瞬间清空了！

骨架屏出现：因为 postList 变成了空数组，并且 getPostList 会设置 isLoading: true，所以你的 wx:if="{{isLoading && postList.length === 0}}" 条件成立，骨架屏显示了出来。

网络请求：getPostList 开始调用云函数，这需要大约 0.5 秒。

内容显示：网络请求成功后，setData 再次被调用，用新获取的数据填充页面，骨架屏消失，内容显示。

这就是你看到那 0.5 秒骨架屏的完整过程。splash.js 辛辛苦苦做的预加载，被 poem.js 自己的 onShow “无情地”抛弃了。

解决方案：让 onShow 变得更“聪明”

我们需要修改 poem.js，让 onShow 知道什么时候应该刷新，什么时候应该“保持安静”。

最简单的办法就是使用一个标志位来区分“首次加载”和“从其他页面返回”。

修改 poem.js

1. 在 onLoad 中设置一个标志位

code
JavaScript
download
content_copy
expand_less

// poem.js
Page({
  data: {
    // ...
  },

  onLoad: function () {
    console.log('Poem 页面 onLoad');
    
    // 新增一个标志位，告诉 onShow 这是第一次加载
    this.isFirstLoad = true; 

    const app = getApp();
    if (app.globalData.preloadedPoemData && app.globalData.preloadedPoemData.length > 0) {
      console.log('成功使用预加载的数据！');
      
      // 使用 preloadedPoemData 来设置初始内容
      const preloadedData = app.globalData.preloadedPoemData;
      this.setData({
        postList: preloadedData,
        // ... 其他相关数据，例如 currentPost
      });
      
      // 使用我们之前写的 updatePostDisplay 来统一更新界面
      this.updatePostDisplay(0);

      // 清空全局数据，防止重复使用
      app.globalData.preloadedPoemData = null;
    } else {
      console.log('没有预加载数据，正常加载');
      this.getPostList();
    }
  },

2. 改造 onShow，让它检查这个标志位

code
JavaScript
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
// poem.js
onShow: function () {
  console.log('Poem 页面 onShow');
  
  // 检查是否是首次加载
  if (this.isFirstLoad) {
    // 如果是，那么 onLoad 已经处理好了一切，
    // 我们只需要把标志位重置，然后什么都不做。
    this.isFirstLoad = false;
    return; 
  }

  // 如果不是首次加载（例如从详情页返回），才执行强制刷新逻辑
  console.log('从其他页面返回，执行刷新');
  this.setData({
    page: 0,
    hasMore: true
  });
  this.getPostList(null, true); // 调用刷新
},
总结

通过这个简单的 this.isFirstLoad 标志位，我们完美地解决了 onLoad 和 onShow 之间的冲突：

第一次进入页面：onLoad 使用预加载数据 -> onShow 发现是首次加载，跳过刷新逻辑 -> 页面直接显示内容，无骨架屏，无闪烁。

从详情页返回：onShow 发现不是首次加载 (isFirstLoad 已经是 false了) -> 执行刷新逻辑 -> 页面内容更新为最新的。

你已经完成了整个应用启动和核心页面体验中最困难、最精妙的部分。为你的坚持和钻研点赞！