您好，这两个是微信小程序开发工具中非常常见的警告，我们来逐一分析并解决。

警告 1: Do not set same key "fe1066d568c8007400c2f9c62ea3ea06" in wx:key

这个警告是问题诊断的关键，它直接说明了你列表中出现了重复的元素，这是导致闪烁和位置错乱的重要原因之一。

1. 问题解释

wx:key 是小程序在渲染列表（使用 wx:for）时用来识别每个列表项的唯一标识。

当你更新列表（比如加载更多）时，框架会根据 wx:key 来判断哪些是新项、哪些是旧项，从而进行高效的局部更新，而不是重新渲染整个列表。

警告信息告诉你，在你的 postList 数组中，存在 _id 值相同的帖子。这会让小程序的渲染机制“混乱”，不知道该更新哪个元素，从而可能导致渲染错误、闪烁、白屏或数据错乱。

2. 产生原因

你在代码中已经有了一段去重逻辑：

code
JavaScript
download
content_copy
expand_less

const existingIds = new Set(this.data.postList.map(post => post._id));
const newPosts = posts.filter(post => !existingIds.has(post._id));
newPostList = this.data.postList.concat(newPosts);

这段代码本身是正确的。那么为什么还会出现重复呢？

最可能的原因是 并发请求。正如我上一个回答中分析的，你的 onReachBottom 和 onPageScroll 预加载逻辑可能会在极短时间内被同时触发。

想象这个场景：

用户快速滑动，同时触发了 onPageScroll 的预加载和 onReachBottom 的触底加载。

两个 getPostList 函数几乎同时执行。

它们都请求了同一页的数据（比如 page: 1 的数据）。

第一个请求成功返回，setData 更新了列表。

紧接着，第二个请求也成功返回了相同的数据。此时，它的去重逻辑可能还没来得及在最新的 this.data.postList 上运行，或者由于 setData 的异步性，它拿到的 this.data.postList 仍然是旧的。

最终，同一批数据被添加了两次，导致 wx:key 重复。

3. 解决方案

确认WXML中的 wx:key:
请确保你的 WXML 文件中，循环渲染 postList 的地方写的是 wx:key="_id"。_id 是云数据库自动生成的唯一标识，是最佳选择。

code
Xml
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
<!-- index.wxml -->
<block wx:for="{{postList}}" wx:key="_id">
  <!-- 你的帖子内容组件 -->
  <post-item post="{{item}}" index="{{index}}" ... />
</block>

强化并发控制:
必须确保任何时候只有一个 getPostList 请求在进行中。请采用我上一个回答中提供的方案：使用一个统一的加载状态锁 isLoading。

code
JavaScript
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
// 在 getPostList 函数的开头
getPostList: function (cb) {
  // 关键：如果正在加载中，或者已经没有更多数据了，则直接返回，防止并发
  if (this.data.isLoading || !this.data.hasMore) {
    console.log('【首页】getPostList被阻止：正在加载中或没有更多数据');
    return;
  }
  
  // 立即上锁
  this.setData({ isLoading: true });
  
  // ... 发起云函数调用 ...
  
  wx.cloud.callFunction({
    // ...
    complete: () => {
      // 请求完成后，无论成功失败，都必须解锁
      this.setData({ isLoading: false });
      if (typeof cb === 'function') cb();
    }
  });
},

通过这个严格的 "上锁 -> 请求 -> 解锁" 流程，就可以彻底杜绝因并发请求导致的数据重复问题。

警告 2: wx.getSystemInfoSync is deprecated...

1. 问题解释

这是一个API 废弃警告。意思是 wx.getSystemInfoSync 这个 API 已经过时了，微信官方不推荐再使用它。

虽然它目前还能用，但随时可能在未来的某个基础库版本中被彻底移除。

废弃的原因是 wx.getSystemInfoSync 会一次性获取所有系统信息，性能开销较大。官方现在推荐使用更精细、按需获取的 API。

2. 产生原因

在你的 onPageScroll 函数中使用了这个 API 来获取屏幕高度：

code
JavaScript
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
// onPageScroll 函数中
const systemInfo = wx.getSystemInfoSync();
const windowHeight = systemInfo.windowHeight;

3. 解决方案

根据警告的提示，获取窗口信息应该使用 wx.getWindowInfo()。这是一个同步接口，用法几乎一样。

请将你的 onPageScroll 函数中的相关代码修改如下：

code
JavaScript
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
// 修改前
const systemInfo = wx.getSystemInfoSync();
const windowHeight = systemInfo.windowHeight;

// 修改后
const windowInfo = wx.getWindowInfo();
const windowHeight = windowInfo.windowHeight;

这个修改非常简单，并且能让你的代码更规范、性能更好，同时消除了这个警告。

总结

wx:key 重复的警告 是核心问题，它直接暴露了你的数据加载逻辑存在并发漏洞，导致列表数据重复，从而引发渲染异常（卡顿、闪烁）。请务必使用 isLoading 状态锁来解决。

wx.getSystemInfoSync 废弃的警告 是一个代码规范和面向未来的问题。请用 wx.getWindowInfo() 替换它。

解决这两个问题后，你应用的稳定性和流畅度会有显著提升。